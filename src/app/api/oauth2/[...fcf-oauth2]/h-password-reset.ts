import type { NextRequest } from 'next/server';

import { parseError, stringifyError } from '@/auth/utils/error-response';
import { parseSearchParams } from '@/auth/utils/parse-search-params';
import { env } from '@/env';
import { db } from '@/server/db';
import { passwordResetRequests, users } from '@/server/db/schema';
import { parseHbs } from '@/utils/parse-hbs';
import { eq } from 'drizzle-orm';
import { z } from 'zod';

const searchParamsSchema = z.object({
  auth_req_pid: z.string().uuid(),
});

const bodySchema = z.object({
  email: z.string().email(),
});

/**
 * --------------------------------------------------------------------------------------------
 * POST - /api/oauth2/password-reset?auth_req_pid=<string>
 *
 * In order for the user to request a password reset he/she must have gonne through the auth
 * process meaning, this person first went to /api/fcf-auth/login which generated the state
 * cookie and redirected to /api/fcf-oauth2/authorize which creates an authorization request
 * as a result. From here we navigate to /login?pid=<pid> where the `pid` is the public
 * id generated by the oauth2 authorization endpoint.
 *
 * Upon navigating to this endpoint we need to ensure that the `pid` search parameter is
 * preset, otherwise we won't allow the user to complete the password reset step as we
 * have not way redirecting the user back to the app he/she came from.
 * --------------------------------------------------------------------------------------------
 */
export async function POSTPasswordReset(req: NextRequest) {
  try {
    const searchParams = req.nextUrl.searchParams;

    const parsedSearchParams = parseSearchParams(searchParams, searchParamsSchema);

    if (!parsedSearchParams.success) {
      throw stringifyError({
        message:
          Object.values(parsedSearchParams.error.flatten().fieldErrors).at(0)?.at(0) ??
          'Something went wrong parsing serch parameters.',
        status: 400,
      });
    }

    const { email } = (await req.json()) as z.infer<typeof bodySchema>;

    const parsed = bodySchema.safeParse({ email });
    if (!parsed.success) {
      throw stringifyError({
        message:
          parsed.error.flatten().formErrors.at(0) ?? 'Something went wrong parsing body payload.',
        status: 400,
      });
    }

    // We need a user in order to add entry to the password reset table down below
    const [user] = await db.select().from(users).where(eq(users.email, email));
    if (!user) {
      return Response.json({ success: true });
    }

    // Insert new password reset request
    const passResetPid = crypto.randomUUID();
    const code = Math.floor(Math.random() * 900000 + 100000).toString();
    await db.insert(passwordResetRequests).values({
      authReqPid: parsedSearchParams.data.auth_req_pid,
      userId: user.id,
      pid: passResetPid,
      code,
    });

    // FIXME: We need to come up with some other way of sending emails.
    const resp = await fetch(env.FCF_SMTP_SERVER, {
      headers: { 'Content-Type': 'application/json' },
      method: 'post',
      body: JSON.stringify({
        para: user.email,
        asunto: 'Verify password reset request',
        mensaje: parseHbs({
          tmplDir: 'email',
          tmplName: 'default',
          title: 'Verify password reset request',
          content: [
            `Use the code below to proceed with your request to reset password. Ignore this message if you did not make this request.`,
            `<div style="font-weight: 500;font-size:24px;">${code}<div>`,
          ],
        }),
      }),
    });

    if (!resp.ok) {
      throw stringifyError({ message: 'Unable to send notification.', status: 400 });
    }

    const data = (await resp.json()) as { exito: boolean; mensaje: string; data: boolean };

    if (!data.exito) {
      throw stringifyError({ message: 'Unable to send password request email.', status: 400 });
    }

    return Response.json({ passResetPid });
  } catch (e) {
    return Response.json(...parseError(e));
  }
}
